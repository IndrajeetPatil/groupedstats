---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, echo=FALSE, warning=FALSE, messsage=FALSE}
options(tibble.width = Inf)

knitr::opts_chunk$set(
  collapse = TRUE,
  dpi = 200,
  message = FALSE,
  warning = FALSE,
  out.width = "100%",
  comment = "#>",
  fig.path = "man/figures/README-"
)
```

# groupedstats: Grouped statistical analysis in a tidy way

[![CRAN_Release_Badge](https://www.r-pkg.org/badges/version-ago/groupedstats)](https://CRAN.R-project.org/package=groupedstats)
[![CRAN Checks](https://cranchecks.info/badges/summary/groupedstats)](https://cran.r-project.org/web/checks/check_results_groupedstats.html)
[![Daily downloads badge](https://cranlogs.r-pkg.org/badges/last-day/groupedstats?color=blue)](https://CRAN.R-project.org/package=groupedstats)
[![Weekly downloads badge](https://cranlogs.r-pkg.org/badges/last-week/groupedstats?color=blue)](https://CRAN.R-project.org/package=groupedstats)
[![R build status](https://github.com/IndrajeetPatil/groupedstats/workflows/R-CMD-check/badge.svg)](https://github.com/IndrajeetPatil/groupedstats)
[![pkgdown](https://github.com/IndrajeetPatil/groupedstats/workflows/pkgdown/badge.svg)](https://github.com/IndrajeetPatil/groupedstats/actions)
[![status](https://tinyverse.netlify.com/badge/groupedstats)](https://CRAN.R-project.org/package=groupedstats)

# Retirement

---

This package is no longer under active development and no new functionality will
be added. You should instead be using `group_map()`, `group_modify()` and
`group_walk()` functions from `dplyr`. See:
<https://dplyr.tidyverse.org/reference/group_map.html>

This is for two reasons-

1. `dplyr 0.8.1` introduced `group_map()`, `group_modify()` and `group_walk()`
   functions that can be used to iterate on grouped dataframes. So if you want
   to do `grouped_` operations, I would highly recommend using these functions
   over `groupedstats` functions since the former are much more general,
   efficient, and faster than the latter. For more, see:
   <https://dplyr.tidyverse.org/reference/group_map.html>

2. There are more general versions of these functions introduced in `broomExtra`
   package:<br> `grouped_tidy`, `grouped_augment`, `grouped_glance`. For more,
   see:
   <https://indrajeetpatil.github.io/broomExtra/reference/index.html#section-grouped-variants-of-generics>

---

# Overview

`groupedstats` package provides a collection of functions to run statistical
operations on multiple variables across multiple grouping variables in a
dataframe. This is a common situation, as illustrated by few example cases-

1. If you have combined multiple studies in a single dataframe and want to run a
   common operation (e.g., linear regression) on **each study**. In this case,
   column corresponding to `study` will be the grouping variable.

2. If you have multiple groups in your dataframe (e.g., clinical disorder groups
   and controls group) and you want to carry out the same operation for **each
   group** (e.g., planned t-test to check for differences in reaction time in
   condition 1 versus condition 2 for both groups). In this case, `group` will
   be the grouping variable.

3. If you have multiple conditions in a given study (e.g., six types of videos
   participants saw) and want to run a common operation between different
   measures of interest for **each condition** (e.g., correlation between
   subjective rating of emotional intensity and reaction time).

4. Combination of all of the above.

# Installation

To get the latest, stable `CRAN` release:

```{r installation1, eval=FALSE, warning=FALSE, messsage=FALSE}
install.packages("groupedstats")
```

You can get the **development** version of the package from `GitHub`. To see
what new changes (and bug fixes) have been made to the package since the last
release on `CRAN`, you can check the detailed log of changes here:
<https://indrajeetpatil.github.io/groupedstats/news/index.html>

If you are in hurry and want to reduce the time of installation, prefer-

```{r installation2, eval=FALSE, warning=FALSE, messsage=FALSE}
# needed package to download from GitHub repo
# install.packages("remotes")

remotes::install_github(
  repo = "IndrajeetPatil/groupedstats", # package path on GitHub
  quick = TRUE
) # skips docs, demos, and vignettes
```

If time is not a constraint-

```{r installation3, eval=FALSE, warning=FALSE, messsage=FALSE}
remotes::install_github(
  repo = "IndrajeetPatil/groupedstats", # package path on GitHub
  dependencies = TRUE, # installs packages which groupedstats depends on
  upgrade_dependencies = TRUE # updates any out of date dependencies
)
```

# Citation

If you want to cite this package in a scientific journal or in any other
context, run the following code in your `R` console:

```{r citation}
citation("groupedstats")
```

# Usage

Below is a short introduction to the currently available functions in this
package:

## `grouped_` versions of `broom` generic functions

These functions are re-exported from `broomExtra` package and provide the most
general versions of `grouped_` functions.

Here is an example

```{r broomExtra_example, warning=FALSE, messsage=FALSE}
# for reproducibility
set.seed(123)

# running glm across two all combinations of two grouping variables
groupedstats::grouped_tidy(
  data = ggstatsplot::Titanic_full, # dataframe
  grouping.vars = c(Class, Age), # grouping variables
  ..f = stats::glm, # function to execute
  # additional arguments passed to `..f`
  formula = Survived ~ Sex,
  family = stats::binomial(link = "logit")
)
```

For more examples, see:
<https://indrajeetpatil.github.io/broomExtra/reference/index.html#section-grouped-variants-of-generics>

## `grouped_summary`

Getting summary for multiple variables across multiple grouping variables. This
function is a wrapper around `skimr::skim_to_wide()`. It is supposed to be a
handy summarizing tool if you have multiple grouping variables and multiple
variables for which summary statistics are to be computed-

```{r grouped_summary1, warning=FALSE, messsage=FALSE}
# for reproducibility
set.seed(123)
library(datasets)
options(tibble.width = Inf) # show me all columns

# note that this dataset has NAs
groupedstats::grouped_summary(
  data = ggplot2::msleep,
  grouping.vars = vore,
  measures = sleep_total:awake,
  measures.type = "numeric"
)
```

This function can be used to get summary of either numeric **or** factor
variables, but **not** both. This is by design. If no `measures` are specified,
the function will compute summary for all variables of the specified type
(`numeric` or `factor`).

If you want summary of variables of `factor` type-

```{r grouped_summary2, warning=FALSE, messsage=FALSE}
# for reproducibility
set.seed(123)
library(ggplot2)
options(tibble.width = Inf) # show me all columns

groupedstats::grouped_summary(
  data = ggplot2::diamonds,
  grouping.vars = c(cut, clarity),
  measures = color,
  measures.type = "factor"
)
```

Note that there is a column corresponding to `top_counts` which is really useful
in case you, let's say, want to plot these counts. But this column is of
`character` type and in wide format. The solution is to use an additional
argument provided for this function:

```{r grouped_summary3, fig.width=8, warning=FALSE, messsage=FALSE}
# for reproducibility
set.seed(123)
library(ggplot2)
library(magrittr)

options(tibble.width = Inf) # show me all columns

# dataframe with counts
(df <- groupedstats::grouped_summary(
  data = ggplot2::diamonds,
  grouping.vars = cut, # for simplicity, let's just use one grouping variable
  measures = color,
  measures.type = "factor",
  topcount.long = TRUE
))

# plot
ggplot2::ggplot(
  data = df,
  mapping = ggplot2::aes(
    x = forcats::fct_inorder(f = factor.level),
    y = count,
    fill = factor.level
  )
) +
  ggplot2::geom_bar(stat = "identity") +
  ggplot2::labs(x = "color", y = "count") +
  ggplot2::facet_grid(facets = ~cut) + # for each level of the factor level
  ggstatsplot::theme_ggstatsplot() +
  ggplot2::theme(legend.position = "none")
```

This produces a long format table with two new columns `factor.level` and its
corresponding `count`, which can then be immediately fed into other pipelines,

e.g., preparing a plot of `mean` and `sd` values in `ggplot2`).

```{r grouped_summary4, warning=FALSE, messsage=FALSE}
# for reproducibility
set.seed(123)
options(tibble.width = Inf) # show me all columns

groupedstats::grouped_summary(
  data = ggplot2::diamonds,
  grouping.vars = c(cut, clarity)
)
```

## `grouped_slr`

This function can be used to run **simple linear regression** (slr) between
different pairs of variables across multiple levels of grouping variable(s). For
example, we can use the `gapminder` dataset to study two relationships of
interest for **each country** across years:

1. life expectancy and GDP (per capita)

2. population GDP (per capita) Thus, in this case we have two regression models
   and one grouping variable with 142 levels (countries)

```{r grouped_slr1, warning=FALSE, messsage=FALSE}
# for reproducibility
set.seed(123)
library(gapminder)
options(tibble.width = Inf) # show me all columns

groupedstats::grouped_slr(
  data = gapminder::gapminder,
  dep.vars = c(lifeExp, pop),
  indep.vars = c(gdpPercap, gdpPercap),
  grouping.vars = country
)
```

Notice the order in which the dependent and independent variables are entered;
there are two separate regression models being run here: `lifeExp ~ gdpPercap`
and `pop ~ gdpPercap` If this order is incorrect, the result will also be
incorrect. So it is always a good idea to check the *formula* column to see if
you have run the correct linear models. Also, note that the estimates are
already standardized, i.e. estimates are standardized regression coefficients
(betas, i.e.).

The prior example was with just one grouping variable. This can be done with
multiple grouping variables as well. For example, with the `diamonds` dataset
from `ggplot2` library, let's assess the relation between carat *and* price of a
diamond for each type of clarity *and* cut-

```{r grouped_slr2, warning=FALSE, messsage=FALSE}
# for reproducibility
set.seed(123)
library(ggplot2)
library(dplyr)
options(tibble.width = Inf) # show me all columns

groupedstats::grouped_slr(
  data = ggplot2::diamonds,
  dep.vars = price,
  indep.vars = carat,
  grouping.vars = c(cut, clarity)
) %>%
  dplyr::arrange(cut)
```

A more general version of this function (`grouped_lm`) will be implemented in
future that will utilize the formula interface of `stats::lm`.

## `grouped_lm`

A more general version of simple linear regression is `stats::lm`, implemented
in `grouped_lm`:

```{r grouped_lm1, warning=FALSE, messsage=FALSE}
# for reproducibility
set.seed(123)
library(groupedstats)

groupedstats::grouped_lm(
  data = mtcars,
  grouping.vars = cyl, # grouping variable (just one in this case)
  formula = mpg ~ am * wt, # note that this function takes a formula
  output = "tidy" # tidy dataframe containing results
)
```

The same function can also be used to get model summaries instead of a tidy
dataframe containing results-

```{r grouped_lm2, warning=FALSE, messsage=FALSE}
# for reproducibility
set.seed(123)
library(groupedstats)

groupedstats::grouped_lm(
  data = ggplot2::diamonds,
  grouping.vars = c(cut, color), # grouping variables
  formula = price ~ carat * clarity, # formula
  output = "glance" # dataframe with model summaries
)
```

## `grouped_aov`

A related function to `stats::lm` is `stats::aov`, which fits an analysis of
variance model for each group. Contrast the output you get here with the
previous output for the same model from `grouped_lm` function. The estimate in
this case with be an effect size (either partial eta-squared or partial
omega-squared).

```{r grouped_aov1, warning=FALSE, messsage=FALSE}
# for reproducibility
set.seed(123)
library(groupedstats)

groupedstats::grouped_aov(
  data = mtcars,
  grouping.vars = cyl, # grouping variable (just one in this case)
  formula = mpg ~ am * wt, # note that this function takes a formula
  output = "tidy" # tidy dataframe with results
)
```

The same function can also be used to compute Tukey's test of Honest Significant
Differences (HSD). For example, we can check for differences in life expectancy
between different continents for all years for which the gapminder survey was
conducted:

```{r grouped_aov2, warning=FALSE, messsage=FALSE}
# for reproducibility
set.seed(123)
library(groupedstats)
library(gapminder)

groupedstats::grouped_aov(
  data = gapminder::gapminder,
  grouping.vars = year,
  formula = lifeExp ~ continent,
  output = "tukey"
)
```

Note that the p-value is adjusted adjusted for the number of tests conducted at
each level of the grouping variable, and not across all tests conducted.

## `grouped_glm`

The option to run generalized linear model (`stats::glm`) across different
levels of the grouping variable is also implemented similarly-

```{r grouped_glm1, warning=FALSE, messsage=FALSE}
# for reproducibility
set.seed(123)

groupedstats::grouped_glm(
  data = ggstatsplot::Titanic_full,
  formula = Survived ~ Sex,
  grouping.vars = Class,
  family = stats::binomial(link = "logit"),
  output = "tidy"
)
```

Note that the `statistic` will either be a `t` (gaussian, e.g.) or a `z`
(binomial, e.g.) value, based on the family of models used.

You can also get a model summary across all models with `broom::glance`
methods-

```{r grouped_glm2, warning=FALSE, messsage=FALSE}
# for reproducibility
set.seed(123)

groupedstats::grouped_glm(
  data = ggstatsplot::Titanic_full,
  formula = Survived ~ Sex,
  grouping.vars = Class,
  family = stats::binomial(link = "logit"),
  output = "glance"
)
```

## `grouped_lmer`

Linear mixed effects analyses (`lme4::lmer`) for all combinations of grouping
variable levels can be carried out using `grouped_lmer`:

```{r grouped_lmer1, warning=FALSE, messsage=FALSE}
# for reproducibility
set.seed(123)
library(gapminder)

# getting tidy output of results
groupedstats::grouped_lmer(
  data = gapminder,
  formula = scale(lifeExp) ~ scale(gdpPercap) + (gdpPercap | continent),
  grouping.vars = year,
  output = "tidy"
)

# getting tidy output of results
groupedstats::grouped_lmer(
  data = gapminder,
  formula = scale(lifeExp) ~ scale(gdpPercap) + (gdpPercap | continent),
  grouping.vars = year,
  output = "glance"
)
```

## `grouped_glmer`

A more generalized version of `lmer` is implemented in `lme4::glmer`, which can
also handle categorical/nominal data. For example, let's say we want to see if
sex of a person was predictive of whether they survived the Titanic tragedy.

```{r grouped_glmer1, warning=FALSE, messsage=FALSE}
# for reproducibility
set.seed(123)

# having a look at the data
dplyr::glimpse(ggstatsplot::Titanic_full)

# running glmer model to get tidy output
groupedstats::grouped_glmer(
  formula = Survived ~ Age + (Age | Class),
  data = ggstatsplot::Titanic_full,
  family = stats::binomial(link = "probit"), # choosing the appropriate GLM family
  control = lme4::glmerControl( # choosing appropriate control
    optimizer = "Nelder_Mead",
    boundary.tol = 1e-07,
    calc.derivs = FALSE,
    optCtrl = list(maxfun = 2e9)
  ),
  grouping.vars = Sex, # grouping variables (just one in this case)
  output = "tidy",
  tidy.args = list(conf.int = TRUE, effects = "fixed")
)

# getting glmer model summaries (let's use the default family and control values)
groupedstats::grouped_glmer(
  data = ggstatsplot::Titanic_full,
  grouping.vars = Sex,
  formula = Survived ~ Age + (Age | Class),
  family = stats::binomial(link = "probit"),
  output = "glance"
)
```

Note that the `statistic` will either be a `t` (gaussian, e.g.) or a `z`
(binomial, e.g.) value, based on the family of models used.

## `grouped_proptest`

This function helps carry out one-sample proportion tests (`stats::chisq.test`)
with a unique variable for multiple grouping variables-

```{r grouped_proptest, warning=FALSE, messsage=FALSE}
# for reproducibility
set.seed(123)
options(tibble.width = Inf) # show me all columns

groupedstats::grouped_proptest(
  data = mtcars,
  grouping.vars = cyl,
  measure = am
)
```

## `grouped_ttest`

This function can help you carry out t-tests, paired or independent, on multiple
variables across multiple groups. Demonstrating how to use this function is
going to first require getting the `iris` dataset into long format. Let's say we
want to investigate if `Sepal` part of the flower has greater measurement
(length or width) than `Petal` part of the flower for **each** *Iris* species.

```{r grouped_ttest1, warning=FALSE, messsage=FALSE}
# for reproducibility
set.seed(123)

# converting the iris dataset to long format
iris_long <- iris %>%
  dplyr::mutate(id = dplyr::row_number(x = Species)) %>%
  tidyr::gather(
    data = .,
    key = "condition",
    value = "value",
    Sepal.Length:Petal.Width,
    convert = TRUE,
    factor_key = TRUE
  ) %>%
  tidyr::separate(
    col = "condition",
    into = c("part", "measure"),
    sep = "\\.",
    convert = TRUE
  ) %>%
  tibble::as_data_frame(x = .)

# check the long format iris dataset
iris_long

# checking if the Sepal part has different dimentions (value) than Petal part
# for each Species and for each type of measurement (Length and Width)
options(tibble.width = Inf) # show me all columns

groupedstats::grouped_ttest(
  data = iris_long,
  dep.vars = value, # dependent variable
  indep.vars = part, # independent variable
  grouping.vars = c(Species, measure), # for each Species and for each measurement
  paired = TRUE # paired t-test
)
```

## `grouped_wilcox`

This function is just a non-parametric variant of the `grouped_ttest`:

```{r grouped_wilcox, warning=FALSE, messsage=FALSE}
# for reproducibility
set.seed(123)
options(tibble.width = Inf) # show me all columns

groupedstats::grouped_wilcox(
  data = iris_long,
  dep.vars = value, # dependent variable
  indep.vars = part, # independent variable
  grouping.vars = c(Species, measure), # for each Species and for each measurement
  paired = TRUE # paired Wilcoxon signed rank test with continuity correction
)
```

While we are at it, let's also check out examples for `t-test` and `Wilcox test`
in case of between-subjects designs.

We will use `diamonds` dataset from `ggplot2` and will see if the price and
depth of a diamond is different for two of our favorite colors (say `E` and `J`)
for each type of clarity.

```{r grouped_wilcox2, warning=FALSE, messsage=FALSE}
# for reproducibility
set.seed(123)

# subset the dataframe with two colors of interest to us
diamonds_short <-
  dplyr::filter(.data = ggplot2::diamonds, color == "E" | color == "J")

# show me all rows and columns
options(tibble.width = Inf, tibble.print_max = Inf)

# t-test
groupedstats::grouped_ttest(
  data = diamonds_short,
  dep.vars = c(carat, price, depth), # note that there three dependent variables
  indep.vars = color, # and just one independent variable
  grouping.vars = clarity, # one grouping variable
  paired = FALSE,
  var.equal = FALSE
)

# wilcox test (aka Mann-Whitney U-test)
groupedstats::grouped_wilcox(
  data = diamonds_short,
  dep.vars = depth:price, # note that you can select variables in range with `:`
  indep.vars = color, # again, just one independent, multiple dependent variables case
  grouping.vars = clarity, # one grouping variable
  paired = FALSE
)
```

We can further focus just on two levels of clarity to further elucidate another
aspect of entering the arguments-

```{r grouped_wilcox3, warning=FALSE, messsage=FALSE}
# for reproducibility
set.seed(123)

# subset the dataframe even further to just select two levels of clarity
diamonds_short2 <-
  dplyr::filter(.data = diamonds_short, clarity == "SI2" | clarity == "SI1")

# wilcox test (aka Mann-Whitney U-test)
groupedstats::grouped_wilcox(
  data = diamonds_short2,
  dep.vars = c(carat, price), # two dependent variables
  indep.vars = c(color, clarity), # two independent variables
  grouping.vars = cut, # one grouping variable
  paired = FALSE
)
```

In these examples, two things are worth noting that generalize to **all**
functions in this package and stem from how tidy evaluation
(<https://adv-r.hadley.nz/evaluation.html>) works:

  - If just one independent variable is provided for multiple dependent
    variables, it will be used as a common variable.

  - If you want to use a selection of variables, you need not use `c()`.

<!-- # Extending with `purrr` -->

<!-- `groupedstats` functions can be further extended with `purrr` package. For -->
<!-- example, let's say we want to run the same linear regression across multiple -->
<!-- grouping variables but want to use different formulas- -->

<!-- ```{r purrr1} -->
<!-- # for reproducibility -->
<!-- set.seed(123) -->
<!-- library(groupedstats) -->

<!-- results_df <- -->
<!--   purrr::pmap_dfr( -->
<!--     .l = list( -->
<!--       data = list(ggstatsplot::movies_long), -->
<!--       grouping.vars = alist(c(mpaa, genre)), # note it's `alist` and not `list` -->
<!--       formula = list( -->
<!--         rating ~ budget, # model 1 -->
<!--         rating ~ log(budget), # model 2 -->
<!--         log(rating) ~ budget, # model 3 -->
<!--         log(rating) ~ log(budget) # model 4 -->
<!--       ), -->
<!--       output = list("glance") # return model diagnostics -->
<!--     ), -->
<!--     .f = groupedstats::grouped_lm, # regression model -->
<!--     .id = "model" -->
<!--   ) %>% # for each combination of mpaa rating and movie genre -->
<!--   dplyr::group_by(mpaa, genre) %>% # arrange by best to worst fits -->
<!--   dplyr::arrange(dplyr::desc(adj.r.squared)) %>% -->
<!--   dplyr::ungroup(.) -->

<!-- # looking at the results -->
<!-- head(results_df) -->
<!-- ``` -->
